<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Web" #>
<#@ assembly name="System.Runtime.Serialization" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="System" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.Serialization.Json" #>
<#@ import namespace="System.Web" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".tt.cs" #>
<#

    var ProductName = "Resource Genereter";
    var ProductVersion = "2.0.1";

#>
<#

    // TODO: 修改相关配置。
    // 检索 resw 的路径。
    string ResourcePath = "Strings";
    // 检索 resw 并生成注释时使用的语言相对 ResourcePath 的路径。
    string SourceLanguagePath = "en";
    // 生成辅助类的命名空间，默认使用 "<ProjectDefaultNamespace>.LocalizedStrings"。
    string LocalizedStringsNamespace = default(string);
    // 生成辅助类的修饰符
    string Modifier = "public";
    // 是否为默认工程，决定是否需要显式定义资源路径。
    bool IsDefaultProject = true;

#>
<#

    var DebugGeneratedCode = false;

    var ns = (LocalizedStringsNamespace ?? (GetProjectDefaultNamespace() + ".LocalizedStrings")).Trim();
    if(!string.IsNullOrEmpty(ns))
        ns = Refine(ns, true);
    Modifier = (Modifier ?? "").Trim();
    var mf = string.IsNullOrEmpty(Modifier) ? "" : Modifier + " ";

    // 用于存放所有资源的 key。
    var names = new Dictionary<string, Dictionary<string, object>>();
    var stringsPath = Path.Combine(GetProjectPath(), ResourcePath, SourceLanguagePath);
    string[] reswPaths;
    string[] resJsonPaths;

    // 当前项目存在 Strings 文件夹。
    if(Directory.Exists(stringsPath))
    {
        // 获取 Strings 文件夹下所有的资源文件的路径。
        reswPaths = Directory.GetFiles(stringsPath, "*.resw", SearchOption.AllDirectories);
        resJsonPaths = Directory.GetFiles(stringsPath, "*.resJson", SearchOption.AllDirectories);
    }
    else
    {
        reswPaths = new string[0];
        resJsonPaths = new string[0];
    }
    foreach(var reswPath in reswPaths)
    {
        AnalyzeResw(names, reswPath);
    }
    foreach(var resJsonPath in resJsonPaths)
    {
        AnalyzeResJson(names, resJsonPath);
    }

    if(!string.IsNullOrWhiteSpace(ns))
    {
#>
namespace <#=ns#>
{
<#
    }

    foreach(var localizedClass in names)
    {
        var resourcePath = (IsDefaultProject ? "" : GetProjectAssemblyName()) + "/" + localizedClass.Key;
        var cache = GetRandomName("_cache");
        var loader = GetRandomName("_loader");
        var className = Refine(localizedClass.Key);
        var classFullName =  $"{ns}.{className}";
        if(!DebugGeneratedCode)
        {
#>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
<#
        }
#>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#=ProductName#>", "<#=ProductVersion#>")]
    <#=mf#>static class <#=className#>
    {
        private static readonly global::System.Collections.Generic.Dictionary<string, string> <#=cache#>
            = new global::System.Collections.Generic.Dictionary<string, string>();

        private static readonly global::Windows.ApplicationModel.Resources.ResourceLoader <#=loader#>
            = global::Windows.ApplicationModel.Resources.ResourceLoader.GetForViewIndependentUse("<#=resourcePath#>");

        public static string GetString(string resourceKey)
        {
            string value;
            if(<#=cache#>.TryGetValue(resourceKey, out value))
                return value;
            else
                return <#=cache#>[resourceKey] = <#=loader#>.GetString(resourceKey);
        }

        public static void ClearCache()
        {
            <#=cache#>.Clear();
        }
<#
        foreach(var name in localizedClass.Value)
        {
            if(string.IsNullOrWhiteSpace(name.Key))
                continue;
            var value = name.Value as string;
            if(value != null)
            {
                WriteProperty("        ", classFullName, "", className, name.Key, value);
            }
            else
            {
                WriteNestedClass("        ", classFullName, "", className, name.Key, (Dictionary<string, object>)name.Value);
            }
        }
#>
    }

<#
    }
    
    if(!string.IsNullOrWhiteSpace(ns))
    {
#>
}
<#
    }
#>
<#+
    public string CombineResourcePath(string root, string reletive)
        => string.IsNullOrEmpty(root) ? reletive : $"{root}/{reletive}";

    public void WriteProperty(string indent, string rootClass, string parent, string parentClass, string key, string value)
    {
        var fullPath = CombineResourcePath(parent, key);
        WriteLine("");
        WriteLine($"{indent}/// <summary>");
        // 转义注释序列
        var comments = new StringReader(value);
        while(true)
        {
            var comment = HttpUtility.HtmlEncode(comments.ReadLine());
            if(comment == null)
                break;
            WriteLine($"{indent}/// <para>{comment}</para>");
        }
        WriteLine($@"{indent}/// </summary>");
        WriteLine($@"{indent}public static string {Refine(key)} => {rootClass}.GetString(@""{AsRaw(fullPath)}"");");
    }

    public void WriteNestedClass(string indent, string rootClass, string parent, string parentClass, string key, Dictionary<string, object> value)
    {
        var cName = Refine(key);
        var fullPath = CombineResourcePath(parent, key);
        var fullCName = $"{parentClass}.{cName}";
        WriteLine("");
        WriteLine($@"{indent}public static class {cName}");
        WriteLine($@"{indent}{{");
        WriteLine($@"{indent}    public static string GetString(string key)");
        WriteLine($@"{indent}    {{");
        WriteLine($@"{indent}        if(string.IsNullOrEmpty(key))");
        WriteLine($@"{indent}            return {rootClass}.GetString(@""{AsRaw(fullPath)}"");");
        WriteLine($@"{indent}        return {rootClass}.GetString(@""{AsRaw(fullPath)}/"" + key);");
        WriteLine($@"{indent}    }}");
        foreach(var item in value)
        {
            var v = item.Value as string;
            if(v != null)
                WriteProperty(indent + "    ", rootClass, fullPath, fullCName, item.Key, v);
            else
                WriteNestedClass(indent + "    ",rootClass, fullPath, fullCName, item.Key, (Dictionary<string, object>)item.Value);
        }
        WriteLine($"{indent}}}");
    }

    public void SetValue(Dictionary<string, Dictionary<string, object>> output, string root, IList<string> path, string value)
    {
        Dictionary<string, object> o;
        output.TryGetValue(root, out o);
        if(o == null)
            output[root] = o = new Dictionary<string, object>();
        SetValueCore(o, path, 0, value);
    }

    public void SetValueCore(Dictionary<string, object> output, IList<string> path, int index, string value)
    {
        if(index == path.Count - 1)
            SetValueCore(output, path[index], value);
        else
        {
            object o;
            output.TryGetValue(path[index], out o);
            var dic = o as Dictionary<string, object>;
            if(dic == null)
                output[path[index]] = dic = new Dictionary<string, object>();
            SetValueCore(dic, path, index + 1, value);
        }
    }

    public void SetValueCore(Dictionary<string, object> output, string path, string value)
    {
        output[path] = value;
    }

    public void AnalyzeResw(Dictionary<string, Dictionary<string, object>> output, string path)
    {
        var className = Path.GetFileNameWithoutExtension(path);
        var document = new XmlDocument();
        document.Load(path);

        // 获取 resw 文件中的 data 节点。
        var dataNodes = document.GetElementsByTagName("data");
        foreach(XmlElement dataNode in dataNodes)
        {
            if(dataNode != null)
            {
                var value = dataNode.GetAttribute("name");
                // key 中包含 ‘.’ 的作为控件的多语言化，不处理。
                SetValue(output, className, value.Split('.', '/'), dataNode["value"].InnerText);
            }
        }
    }

    public void AnalyzeResJson(Dictionary<string, Dictionary<string, object>> output, string path)
    {
        var className = Path.GetFileNameWithoutExtension(path);
        using(var reader = new StreamReader(path, true))
        using(var ms = new MemoryStream())
        using(var writer = new StreamWriter(ms, new System.Text.UTF8Encoding(false)))
        {
            var line = default(string);
            while((line = reader.ReadLine()) != null)
            {
                writer.WriteLine(line);
            }
            writer.Flush();
            ms.Position = 0;
            var xmlreader = JsonReaderWriterFactory.CreateJsonReader(ms, new XmlDictionaryReaderQuotas());
            var doc = new XmlDocument();
            doc.Load(xmlreader);
            var root = doc.FirstChild;
            var p = new List<string>();
            foreach(XmlElement item in root.ChildNodes)
            {
                AnalyzeNode(output, className, p, item);
            }

        }
    }

    public void AnalyzeNode(Dictionary<string, Dictionary<string, object>> output, string root, List<string> path, XmlElement node)
    {
        var nodeName = GetNodeName(node);
        if(string.IsNullOrWhiteSpace(nodeName)||nodeName.StartsWith("_"))
            return;
        var currentName = GetNodeName(node).Split('/');
        path.AddRange(currentName);
        if(node.FirstChild.NodeType == XmlNodeType.Text)
        {
            var text = default(string);
            foreach(XmlText item in node.ChildNodes)
            {
                text += item.InnerText;
            }
            SetValue(output, root, path, text);
        }
        else
        {
            foreach(XmlElement item in node.ChildNodes)
            {
                AnalyzeNode(output, root, path, item);
            }
        }
        var currentNameLength = currentName.Length;
        path.RemoveRange(path.Count - currentNameLength, currentNameLength);
    }

    public string GetNodeName(XmlElement node)
    {
        var name = node.GetAttribute("item");
        if(string.IsNullOrEmpty(name))
            return node.Name;
        return name;
    }

    private HashSet<string> keywords = new HashSet<string>() { "abstract", "as", "base", "bool", "break", "byte", "case", "catch", "char", "checked", "class", "const", "continue", "decimal", "default", "delegate", "do", "double", "else", "enum", "event", "explicit", "extern", "false", "finally", "fixed", "float", "for", "foreach", "goto", "if", "implicit", "in", "int", "interface", "internal", "is", "lock", "long", "namespace", "new", "null", "object", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof", "stackalloc", "static", "string", "struct", "switch", "this", "throw", "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe", "ushort", "using", "virtual", "void", "volatile", "while" };

    private HashSet<string> used = new HashSet<string>() { "GetString", "ClearCache", "ReferenceEquals", "Equals" };

    public string AsRaw(string value)
    {
        return value?.Replace("\"", "\"\"") ?? "";
    }

    public string Refine(string name, bool allowDot = false)
    {
        if(allowDot)
        {
            var names = name.Split('.');
            return string.Join(".", names.Select(n => Refine(n)));
        }
        else
        {
            if(keywords.Contains(name))
                return "@" + name;
            if(used.Contains(name))
                return "_" + name;
            if(string.IsNullOrWhiteSpace(name))
                return GetRandomName("__");
            if(!isValidStartChar(name[0]))
                name = "_" + name;
            for(var i = 1; i < name.Length; i++)
            {
                if(!isValidPartChar(name[i]))
                    name = name.Replace(name[i], '_');
            }
            return name;
        }
    }

    private bool isValidStartChar(char ch)
    {
        return ch == '_' || isLetter(ch);
    }

    private bool isValidPartChar(char ch)
    {
        var c = (int)char.GetUnicodeCategory(ch);
        return c == 5
            || c == 6
            || c == 8
            || c == 18
            || c == 15
            || isLetter(ch);
    }

    private bool isLetter(char ch)
    {
        var c = (int)char.GetUnicodeCategory(ch);
        return c < 5 || c == 9;
    }

    private Random ran = new Random();

    public string GetRandomName(string head)
    {
        return head + ran.Next();
    }

    // 获取当前 T4 模板所在的工程的目录。
    public string GetProjectPath()
    {
        return Host.ResolveAssemblyReference("$(ProjectDir)");
    }

    // 获取当前 T4 模板所在的工程的默认命名空间。
    public string GetProjectDefaultNamespace()
    {
        IServiceProvider serviceProvider = (IServiceProvider)this.Host;
        EnvDTE.DTE dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
        EnvDTE.Project project = (EnvDTE.Project)dte.Solution.FindProjectItem(this.Host.TemplateFile).ContainingProject;
        return project.Properties.Item("DefaultNamespace").Value.ToString();
    }

    // 获取当前 T4 模板所在的工程的程序集名称。
    public string GetProjectAssemblyName()
    {
        IServiceProvider serviceProvider = (IServiceProvider)this.Host;
        EnvDTE.DTE dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
        EnvDTE.Project project = (EnvDTE.Project)dte.Solution.FindProjectItem(this.Host.TemplateFile).ContainingProject;
        return project.Properties.Item("AssemblyName").Value.ToString();
    }
#>
